# -*- coding: utf-8 -*-
"""Итоговая работа.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VdE1v60m3iFtfmDWu_Mcj9B2OELT5R9k
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats as st

"""1. satisfaction_level - Уровень удовлетворенности работой
2. Last_evaluation - Время с момента последней оценки в годах
3. number_projects - Количество проектов, выполненных за время работы
4. average_monthly_hours - Среднее количество часов на рабочем месте в месяц
5. time_spend_company - Стаж работы в компании в годах
6. work_accident - Происходили ли несчастные случаи на рабочем месте с сотрудником
7. left - уволился ли сотрудник
8. promotion_last_5years - повышался ли сотрудник за последние пять лет
9. department - отдел в котором работает сотрудник
10. salary - относительный уровень зарплаты

###1. Загрузите файл HR.csv в pandas dataframe -5б
"""

df = pd.read_csv('HR.csv')
df.info()
df

"""###2. Рассчитайте основные статистики для переменных
(среднее,медиана,мода,мин/макс,сред.отклонение).
-10б
"""

df.describe()

print('Мода уровня удовлетворенности',df['satisfaction_level'].mode()[0])
print('Мода Времени с момента последней оценки в годах',df['last_evaluation'].mode()[0])
print('Мода Количества проектов, выполненных за время работы',df['number_project'].mode()[0])
print('Мода Среднего количества часов на рабочем месте в месяц',df['average_montly_hours'].mode()[0])
print('Мода Стажа работы в компании в годах',df['time_spend_company'].mode()[0])
print('Мода Несчастных случаев',df['Work_accident'].mode()[0])
print('Мода увольнений',df['left'].mode()[0])
print('Мода повышений в течение 5 лет',df['promotion_last_5years'].mode()[0])
print('Мода департаментов',df['department'].mode()[0])
print('Мода уровеня зарплаты',df['salary'].mode()[0])

"""###3 Рассчитайте и визуализировать корреляционную матрицу для количественных переменных. -10б
Определите две самые скоррелированные и две наименее
скоррелированные переменные.
"""

# Посчитаем коэффициенты корреляции между всеми показателями и построим тепловую карту для понимания

sns.set(rc={'figure.figsize':(8, 6)})
sns.heatmap(df.corr(), annot=True, cmap='PuBu')

"""* Матрица корреляции, представляющая собой квадратную таблицу, которая показывает коэффициенты корреляции между несколькими попарными комбинациями переменных, где:
> -1 указывает на совершенно отрицательную линейную корреляцию.
> 0 указывает на отсутствие линейной корреляции.
> 1 указывает на абсолютно положительную линейную корреляцию.

Исходя из матрицы, мы имеем данные результаты
* две самые скоррелированные переменные: Количество часов и количество проектов сотрудника(0,42)
* две наименее скоррелированные переменные: Уход сотрудника из компании и Уровень удовлетворенности работой (-0,39)

### 4 Рассчитайте сколько сотрудников работает в каждом департаменте. - 5б
"""

# Смотрим какие существуют департаменты в компании
df['department'].unique()

df.groupby('department').size()

"""### 5 Показать распределение сотрудников по зарплатам. -5б"""

salaries = df.groupby('salary').count()['satisfaction_level']
salaries

salaries = sorted(salaries, reverse=True)
r = ['low', 'medium' ,'high']
plt.bar(r, salaries)
plt.xlabel('Уровень зарплаты')
plt.ylabel('Количество сотрудников')
plt.title('Плотность распределения значений')
plt.show()

"""### 6 Показать распределение сотрудников по зарплатам в каждом департаменте по отдельности - 5б"""

t = df.pivot_table(index='department', columns='salary', aggfunc='size')
t

t.plot(kind='bar')

"""### 7.Проверить гипотезу, что сотрудники с высоким окладом проводят на работе больше времени, чем сотрудники с низким окладом - 10б"""

# h0 = Время на работе не влияет на оклад сотрудника
# h1 = Время работы влиет на оклад

salary_low = df[df['salary']=='low']['average_montly_hours']
salary_high = df[df['salary']=='high']['average_montly_hours']

df, p = st.ttest_ind(salary_low, salary_high)

if p > 0.05:
    print('Не отклоняем нулевую гипотезу, средние, вероятно, одинаковые')
else:
    print('Отклоняем нулевую гипотезу, средние, вероятно, различаются')

"""### 8.Рассчитать следующие показатели среди уволившихся и не уволившихся сотрудников (по отдельности) -10б
* Доля сотрудников с повышением за последние 5 лет
* Средняя степень удовлетворенности
* Среднее количество проектов
"""

retireds = df[df['left']==0]
workers = df[df['left']==1]

indicators = pd.DataFrame()
rows = []

rows.append(
    {
    'Показатель': 'Доля получивших повышение',
    'Уволившиеся': round(retireds.promotion_last_5years.value_counts(normalize=True)[1], 3),
    'Действующие': round(workers.promotion_last_5years.value_counts(normalize=True)[1], 3)
    }
)

rows.append(
    {
    'Показатель': 'Средняя степень удовлетворенности',
    'Уволившиеся': round(retireds.satisfaction_level.mean(), 3),
    'Действующие': round(workers.satisfaction_level.mean(), 3)
    }
)

rows.append(
    {
    'Показатель': 'Среднее количество проектов',
    'Уволившиеся': round(retireds.number_project.mean(), 3),
    'Действующие': round(workers.number_project.mean(), 3)
    }
)

for row in rows:
    indicators = pd.concat([indicators, pd.DataFrame([row])])

indicators

"""### Разделить данные на тестовую и обучающую выборки
###Построить модель LDA, предсказывающую уволился ли сотрудник на основе имеющихся факторов (кроме department и salary)
###Оценить качество модели на тестовой выборки
"""

# разделяем выборку на тренировочную и тестовую
from sklearn.model_selection import train_test_split

x = df[['satisfaction_level','last_evaluation','number_project','average_montly_hours','time_spend_company','Work_accident','left','promotion_last_5years']]
y = df['left']

X_train, X_test, y_train, y_test = train_test_split(x, y, random_state=42)

# импортируем LDA-функционал
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis

lda = LinearDiscriminantAnalysis()

# обучаем модель
lda.fit(X_train, y_train)

lda.predict(X_test)

# Оцениваем качество модели на тестовой выборке
from sklearn.metrics import accuracy_score
accuracy_score(y_test, lda.predict(X_test))

"""Коэффициент детерминации - 0.83, а это означает, что точность бодели высокая(коэффициент стремится к 1)."""